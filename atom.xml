<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victor Su&#39;s Blog</title>
  
  <subtitle>随便记点什么吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://victorsu.tk/"/>
  <updated>2020-07-28T09:03:16.507Z</updated>
  <id>https://victorsu.tk/</id>
  
  <author>
    <name>Victor Su</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识动态规划的一点理解</title>
    <link href="https://victorsu.tk/2018/01/28/first-understanding-of-dynamic-programming/"/>
    <id>https://victorsu.tk/2018/01/28/first-understanding-of-dynamic-programming/</id>
    <published>2018-01-28T08:58:31.000Z</published>
    <updated>2020-07-28T09:03:16.507Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚开始入坑LeetCode，遇到了动态规划的题目。以前只是知道动态规划，用得很少，基本是局限在用空间换时间等“Memoization”之类的技巧，最近才找了一些资料，对动态规划有了真正的了解。但因为做的题目太少，有一些地方还不太明白，先记录下来，以后慢慢加深理解。</p><a id="more"></a><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="noopener">Wikipedia</a>:</p><blockquote><p>Dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>动态规划的核心在于将一个不好解决的问题拆分为子问题，递归地拆分下去之后，规模很小（如N=1）时候的子问题很容易解决，结合拆分过程中得到的状态转移方程（解决了N&lt;=k -&gt; N=k+1怎么变）即可解决原问题。动态规划如果找到了状态转移方程就很好解决，而记忆化、递归、递推等等都只是一些技巧，并不是动态规划的核心。</p><h3 id="状态与状态转移方程："><a href="#状态与状态转移方程：" class="headerlink" title="状态与状态转移方程："></a>状态与状态转移方程：</h3><p>个人非官方理解：一个规模为N=k的问题可以理解为第k个状态，记N=k时待求的量为F<sub>k</sub>，那么怎么由N&lt;=k得到N=k+1，即F<sub>k+1</sub>=f(F<sub>&lt;=k</sub>)就是状态转移方程。<strong>动态规划最难的地方便在于怎么合适地定义状态，使得能够找到状态转移方程，找到方程了就相当于找到了怎么将原问题拆分成子问题减小规模。</strong></p><h2 id="一些例子："><a href="#一些例子：" class="headerlink" title="一些例子："></a>一些例子：</h2><h3 id="Fibonacci序列"><a href="#Fibonacci序列" class="headerlink" title="Fibonacci序列"></a>Fibonacci序列</h3><p>Fibonacci序列：1，1，2，3，5，8，13 ……</p><p>问题：求Fibonacci序列中第n个元素</p><p>比较明显，记待求的量（Fibonacci序列中第n个元素）为F<sub>n</sub>，由递推公式即可以获得状态转移方程F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></p><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p>问题：给定一个长度为n数列，求其最长上升子数列的长度。<br>以1 7 2 8 3 4为例。这个数列的最长上升子数列是 1 2 3 4，长度为4；次长的长度为3， 包括 1 7 8; 1 2 3 等。</p><p>如果仍像Fibonacci序列那样采取最直观的方式定义状态，记该数列（长度为n）的最长上升子数列的长度为F<sub>n</sub>，求状态转移方程时将用到F<sub>k</sub> ( k &lt; n ) ，而F<sub>k</sub> ( k &lt; n ) 不是确定的（只知道长度是k），没有意义。我们需要一个确定的规模缩小的状态，所以需要在原数列中特定位置截取长为k的子数列。一种取法是，原数列L，取L[1-&gt;k][注1]作为规模缩小后的状态，这样子保证了，最初的状态是L[1-&gt;n]没有变，而随着规模缩小，每次得到的数列依然是确定的。</p><p>因此，我们将问题表述调整为：给定一个长度为n数列，求其子数列L[1-&gt;n]的最长上升子数列长度。记其子数列L[1-&gt;n]的最长上升子数列长度为F<sub>n</sub>。尝试得到状态转移方程，思路过程如下：</p><p>已知序列a b c d e f g h的最长上升子序列是a b d f，找a b c d e f g h i最长上升子序列，若i = f，则必定是a b d f i（长度为4 + 1 = 5），若i &lt;= f，则需要得到原先的序列第二长的上升子序列（如a c g），如果i &gt; g，则最长子序列可以是a c g i或者a b d f。（虽然此时长度都是4，但是不单需要知道长度，还得记录子序列的最后一个元素，因为判断i与f关系的时候用到了。因此这里需要知道第二长的序列，并求出最长的序列。）而原先的序列的第二长的子序列不好算，若尝试算如下：</p><p>设F<sub>n</sub> = ( l<sub>Bn</sub>, B<sub>n</sub>, l<sub>Cn</sub>, C<sub>n</sub> ) 。B<sub>n</sub>是L[1-&gt;n]的最长上升子序列的最后一个元素构成的列表（最长上升子序列可能不止一个），l<sub>Bn</sub>是L[1-&gt;n]的最长上升子序列的长度，C<sub>n</sub>是L[1-&gt;n]的第二长上升子序列的最后一个元素构成的列表，l<sub>Bn</sub> 是L[1-&gt;n]的第二长上升子序列的长度。（例如上述序列a -&gt; h即为：(4, [f], 3, [g])。）设了4个量，因为由上面分析过程看出，从n-1状态得到n状态的最长上升子序列长度，最少都需要这四个量。接着推导状态转移方程就会发现，由F<sub>n-1</sub>计算C<sub>n</sub>的时候，是需要知道n-1状态下的第三长的上升子序列的，而目前设的4个量中并没有……也就是还得引入D<sub>n</sub>，l<sub>Dn</sub>……这样子就导致需要引入F<sub>n</sub>等等，没办法计算。<em>（如果不需要引入新的量的话，理论上是可以这么计算的。）</em></p><p>以上是经过查找了不少资料，又过了几天之后自己尝试推导的结果。所以说寻找合适的状态定义还是蛮困难的Orz。</p><p>怎么做？<strong>并不需要直接得到结果（最长上升子序列长度），可以得到一系列相关结果后从中选择合适的。把问题改为求一些相关结果，此时可以加一些限制，使得问题容易解决。</strong> 而这里可以限制以第几个元素开头或者结尾。</p><p>问题改成：在长为n的这个序列中，求以第k个元素结尾的最长上升子序列的长度。该序列的最长上升子序列的长度（原问题），是这个问题所有结果的最大值。故令F<sub>k</sub> 为第k个元素结尾的最长上升子序列的长度，则有状态方程：</p><p>F<sub>k</sub> = max{ F<sub>i</sub> + 1 | L[i] &lt; L[k], i = from 1 to (k - 1) }，即对i从1到k-1（所有比k小的状态），若L[i] &lt; L[k]，则把这个值 +1 之后取出来，所有取出来的值取最大即得到F<sub>k</sub>。（需要L[i] &lt; L[k]是因为待求的是以第k个元素结尾的。）</p><p><em><u>Notes:</u></em></p><ol><li><p>与上一个想法不一样的在于，缩小规模不是靠考虑小一点的子串L[1-&gt;k]，而是规定了子序列结尾字符的位置。从而避免了在上一个想法中，确定子序列长度的时候需要用上子序列最后一个字符，导致需要多设一个量记录子序列是什么的困境。</p></li><li><p><strong>状态转移方程中由F<sub>k-1</sub>求F<sub>k</sub>不好求，这里不管k-1状态是什么样， 直接由小于k的所有合适状态中取最大值。</strong></p></li></ol><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p>问题：给定一个字符串序列，找出最长的回文子序列长度。<br>例如absdbhjah，回文子序列有abdba，hjh等，最长回文子序列长度是5。</p><p>如果令F<sub>k</sub>=L[1-&gt;k]的最长回文子序列长度，由F<sub>k-1</sub>求F<sub>k</sub>时，末尾多了一个元素，要知道F<sub>k</sub>有没有比F<sub>k-1</sub>大，需要知道F<sub>k-1</sub>的时候的回文子序列第一个元素是不是L[1]，这个可以通过引入多一个量或者修改问题描述增加开始位置限制等来解决。但是这些方法对于第一个元素不是L[1]的情况依然不好求F<sub>k</sub>。这里可以令F<sub>m,n</sub>=L[m-&gt;n]的最长回文子序列。原问题则是求F<sub>1,N</sub>。则状态转移方程如下：</p><p>F<sub>m,n</sub> = F<sub>m+1,n-1</sub> + 2,  L[m] == L[n]<br>F<sub>m,n</sub> = max{ F<sub>m,n-1</sub> , F<sub>m+1,n</sub> },  L[m] != L[n]</p><p><u><em>Notes:</em></u></p><ol><li><p>同样的，在L[m] != L[n]的情况，反正回文子序列不会同时包含L[m]与L[n]，那么最长回文子序列要么包含L[m]不包含L[n]（F<sub>m,n-1</sub>），要么那么最长回文子序列要么包含L[n]不包含L[m]（F<sub>m+1,n</sub>），要么都不包含（F<sub>m,n-1</sub>或者F<sub>m+1,n</sub>，两者相等），直接取最大值即可，不用去判断</p></li><li><p>当自变量有两个及以上（m, n两个）时，<strong>由F<sub>m,n</sub>入手思考，怎么才能得到F<sub>m,n</sub>（可以用上F<sub>i,j</sub>（i &lt; m, j &lt; n））</strong>；而不要倒过来想F<sub>m,n</sub>怎么得到F<sub>m+1,n+1</sub>。</p></li></ol><p>另外一种考虑：</p><p>令F<sub>m,n</sub> = L中以L[m]开头，L[n]结尾的最长回文子序列，则记原问题为P<sub>N</sub>，P<sub>N</sub> = T<sub>1,N</sub> = max{ F<sub>i,j</sub> i from 1 to N, j from 1 to N, i &lt; j }，则得到状态转移方程：</p><p>F<sub>m,n</sub> = 0,  L[m] != L[n]<br>F<sub>m,n</sub> = T<sub>m+1,n-1</sub> + 2,  L[m] == L[n]</p><p>但是耗时明显要比上一个方法大，每一个T的计算都要比较n<sup>2</sup>个数据。（如果优化，对反复用到的数据（是F不是T，T只是max的记号而已，将max{}代入T来理解，T<sub>i,j</sub>与T<sub>i-1,j-1</sub>没有关系）做缓存，依然无法避免反复比较的问题。）</p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>问题：有N件物品和一个容量为V的背包。第i件物品的占用空间是cost[i]，价值是value[i]。求解将哪些物品装入背包可使价值总和最大。</p><p>如果令F<sub>v</sub>=将这些物品（N个）放入容量为V的背包中的最大价值，则状态转移方程不好求，因为背包容量增大的时候，可以取出一些物品再放入一些，可能能产生更大价值。所以这里如同上一个例子（回文序列），将另一个影响量物品数也作为<em>自变量</em>。如下：</p><p>令F<sub>n,v</sub>=将前n件物品放入容量为v的背包中所能获得的最大价值。则可得到状态转移方程：</p><p>F<sub>n,v</sub> = max{ F<sub>n-1,v</sub>, F<sub>n-1,v-cost[n]</sub> + value[n] }<br><strong>即分成两种情况，最后一个物品放与不放。</strong> 如果不放，等同于前n-1件物品放入容量为v的背包中获得的最大价值F<sub>n-1,v</sub>。如果放，需要先将背包腾出足够空间，剩下空间放前n-1个物品，所以是F<sub>n-1,v-cost[n]</sub> + value[n]，两者直接比较取最大值。</p><h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><p>知乎答主<a href="https://www.zhihu.com/people/crackinterview/activities" target="_blank" rel="noopener">ninechapter</a>在<a href="https://www.zhihu.com/question/23995189/answer/151764127" target="_blank" rel="noopener">什么是动态规划？动态规划的意义是什么？ - ninechapter的回答 - 知乎</a>提到：</p><blockquote><p>动态规划的常见类型分为：</p><ul><li>矩阵型</li><li>序列型</li><li>双序列型</li><li>划分型</li><li>区间型</li><li>背包型</li><li>状态压缩型</li><li>树型</li></ul></blockquote><p>而因为目前遇到的题目不多，先记下来，以后遇到再留意。</p><h2 id="动态规划实现的优化"><a href="#动态规划实现的优化" class="headerlink" title="动态规划实现的优化"></a>动态规划实现的优化</h2><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>通常使用递归，求f(k)需要先求f(k-1)-&gt;f(k-2)…可以将存在重复计算的部分在表中记录下来，之后遇到不需要计算而是改为查表。如Fibonacci序列，F(5)-&gt;需要F(4)+F(3)，而在计算F(4)的时候又要计算F(3)+F(2)，重复计算。所以可以用表记录F(x)，当F(x)已存在的时候直接查表。</p><h3 id="自下向顶"><a href="#自下向顶" class="headerlink" title="自下向顶"></a>自下向顶</h3><p>通常使用递推，f(n)状态转移方程已知，先求f(1)-&gt;f(2)-&gt;…-&gt;f(n)。同样可以考虑记录重复计算部分，并且自下向顶更容易优化占用的空间。如Fibonacci序列，自顶向下空间复杂度是O(n)，而如果从状态转移方程入手自下向顶，F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> ，可以看到每求下一个数只用到前两个数，其他的数算出来之后不用保存。空间复杂度优化至O(1)。</p><p>01背包问题的空间复杂度优化：</p><p>如果记录中间结果避免重复计算，有两个自变量n，v，不做优化空间复杂度为O(N*V)，但考虑状态转移方程：F<sub>n,v</sub> = max{ F<sub>n-1,v</sub>, F<sub>n-1,v-cost[n]</sub> + value[n] }，发现计算F<sub>n,v</sub>只需要用到F<sub>n-1,x</sub> ( x &lt;= v) 的数据，即没必要保存整个N*V矩阵，只需要保存当中的两行（第n行与第n-1行）就行了。空间复杂度优化至O(2V)。实现：只用2*V矩阵，当计算第n行时，可以将数据保存在矩阵中的第n % 2行。</p><p>进一步优化：上述是记录第n行与第n-1行，能否只记录一行？当计算第n行时，记录的是第n-1行，如果每计算第n行的一个即覆盖第n-1行的一个记录，并保证这个记录之后不会用到即可优化，因此关键在于第n行的元素的计算顺序。状态转移方程可以看出，计算F<sub>n,v</sub>用到的元素是F<sub>n-1,x</sub> ( x &lt;= v) ，所以计算第n行时若是从(n, max)计算到(n, 1)，便能保证没有需要用到的元素(n, x)都没有被覆盖。空间复杂度优化至O(V)。</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p>学习的过程中参考了不少资料，以下是遇到的一些比较有用的。</p><ul><li><a href="https://www.zhihu.com/question/23995189" target="_blank" rel="noopener">什么是动态规划？动态规划的意义是什么？</a></li><li><a href="https://www.zhihu.com/question/39948290" target="_blank" rel="noopener">如何理解动态规划？</a></li><li><a href="https://www.cnblogs.com/William-xh/p/7305877.html" target="_blank" rel="noopener">01背包问题的详细概述</a></li><li><a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">背包九讲</a></li></ul><h2 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h2><ul><li><p>动态规划问题中，从数学的角度时间复杂度应该如何求解？尤其是当使用了递归和记忆化的时候？</p></li><li><p>看到一些描述说到动态规划与图论的关系，但是不太明白是怎么理解：</p><blockquote><p>所有的动态规划问题都可以转变为状态空间内大量可行状态点和有效转移构成的图的从初始状态到最终状态的最短路问题。</p><p>动态规划其实是一个广义有向无环图上的最短路问题。这个图怎么建立？将所有的状态都抽象为节点。从节点i到节点j的边权看做是从状态i到状态j所作出决策后的payoff。那么，我们的目标状态就是求解，从一个初始状态到最终状态的最短路问题。</p><p>只要图建出来了，用拓扑排序，dfs，bfs甚至最短路算法都能解。</p></blockquote></li><li><p>另外有知乎答主从图的角度理解动态规划并给出了一个据说更容易操作的方法，但是不太理解。<a href="https://www.zhihu.com/question/39948290/answer/83942329" target="_blank" rel="noopener">如何理解动态规划？ - 冒泡的回答 - 知乎</a></p></li></ul><p>[注1]: L[1-&gt;k]：个人临时用的一个写法，代表列表L中，从第1个元素开始，到第k个元素截止（包含第1个和第k个）得到的子列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚开始入坑LeetCode，遇到了动态规划的题目。以前只是知道动态规划，用得很少，基本是局限在用空间换时间等“Memoization”之类的技巧，最近才找了一些资料，对动态规划有了真正的了解。但因为做的题目太少，有一些地方还不太明白，先记录下来，以后慢慢加深理解。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://victorsu.tk/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="https://victorsu.tk/tags/Dynamic-Programming/"/>
    
      <category term="动态规划" scheme="https://victorsu.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
